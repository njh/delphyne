#!/usr/bin/env bash
#
# delphyne by @njh
# With varius functions stolen from dehydrated by lukas2511
#
# Source: https://github.com/njh/delphyne
#
# This script is licensed under The MIT License (see LICENSE for more information).

set -e
set -u
set -o pipefail

VERSION="0.0.1"
API_BASE_PATH="https://api.mythic-beasts.com/beta/dns"

# Load configuration from .env file, if it exists
if [ -f .env ]; then
  # shellcheck disable=SC1091
  source .env
fi
if [ -f .env.local ]; then
  # shellcheck disable=SC1091
  source .env.local
fi


# Create (identifiable) temporary files
_mktemp() {
  mktemp "${TMPDIR:-/tmp/}delphyne-XXXXXX"
}

# Different sed version for different os types...
_sed() {
  if [[ "${OSTYPE}" = "Linux" || "${OSTYPE:0:5}" = "MINGW" ]]; then
    sed -r "${@}"
  else
    sed -E "${@}"
  fi
}

# Print error message and exit with error
_exiterr() {
  echo "ERROR: ${1}" >&2
  exit 1
}

# Remove newlines and whitespace from json
clean_json() {
  tr -d '\r\n' | _sed -e 's/ +/ /g' -e 's/\{ /{/g' -e 's/ \}/}/g' -e 's/\[ /[/g' -e 's/ \]/]/g'
}

# Get string value from json dictionary
get_json_string_value() {
  local filter
  filter=$(printf 's/.*"%s": *"\([^"]*\)".*/\\1/p' "$1")
  sed -n "${filter}"
}

# Get integer value from json
get_json_int_value() {
  local filter
  filter=$(printf 's/.*"%s": *\([0-9]*\).*/\\1/p' "$1")
  sed -n "${filter}"
}

# Get array value from json dictionary
get_json_array_value() {
  local filter
  filter=$(printf 's/.*"%s": *\\[\([^]]*\)\\].*/\\1/p' "$1")
  sed -n "${filter}"
}

# Get sub-dictionary from json
get_json_dict_value() {
  local filter
  filter=$(printf 's/.*"%s": *{\([^}]*\)}.*/\\1/p' "$1")
  sed -n "${filter}"
}

# Get array value from json dictionary
get_json_array_as_lines() {
  _sed -n $'s/[ \t]*"([^"]*)",?[ \t]*/\\1\\\n/gp'
}

# Delete blank lines
delete_empty_lines() {
  _sed $'/^\r?$/d'
}

# Check for script dependencies
check_dependencies() {
  # just execute some dummy and/or version commands to see if required tools exist and are actually usable
  _sed "" < /dev/null > /dev/null 2>&1 || _exiterr "This script requires sed with support for extended (modern) regular expressions."
  command -v mktemp > /dev/null 2>&1 || _exiterr "This script requires mktemp."

  # curl returns with an error code in some ancient versions so we have to catch that
  set +e
  CURL_VERSION="$(curl -V 2>&1 | head -n1 | awk '{print $2}')"
  retcode="$?"
  set -e
  if [[ ! "${retcode}" = "0" ]] && [[ ! "${retcode}" = "2" ]]; then
    _exiterr "This script requires curl."
  fi
}

display_error() {
  local headerspath="${1}"
  local bodypath="${2}"
  local parsed_error=false
  local errstr

  # If the response was JSON, try and parse it
  if grep -iq "Content-Type: *application/json" "${headerspath}"; then
    # Single error message?
    errstr="$(clean_json < "${bodypath}" | get_json_string_value error)"
    if [ -n "${errstr}" ]; then
      parsed_error=true
      echo " => ${errstr}" >&2
    else
      # Array of error messages?
      errstr="$(clean_json < "${bodypath}" | get_json_array_value errors)"
      if [ -n "${errstr}" ]; then
        parsed_error=true
        get_json_array_as_lines <<< "${errstr}" | while read -r line; do
          if [ -n "${line}" ]; then
            echo " => ${line}" >&2
          fi
        done
      fi
    fi
  fi

  # If we failed to parse the error message, display the full response
  if [ "$parsed_error" = false ] ; then
    echo " => An error occurred while making request" >&2
    echo >&2
    echo "Response:" >&2
    cat "${headerspath}" >&2
    cat "${bodypath}" >&2
    echo >&2
  fi
}

# Send http(s) request with specified method
http_request() {
  local method="${1}"
  local url="${API_BASE_PATH}${2}"
  local body="${3:-}"

  tempbody="$(_mktemp)"
  tempheaders="$(_mktemp)"

  if [[ -z "${MYTHIC_BEASTS_API_KEY}" || -z "${MYTHIC_BEASTS_SECRET}" ]]; then
    echo "Please ensure that MYTHIC_BEASTS_API_KEY and MYTHIC_BEASTS_SECRET are defined." >&2
    echo "This can be done either as an environment variable, or by defining in a .env file in the working directory." >&2
    exit 2
  fi

  # Build up the curl command arguments as an array
  cmd=("${CURL}" '--silent' '--show-error')
  if [ -n "${ip_version}" ]; then
    cmd+=("${ip_version}")
  fi
  cmd+=('--request' "${method}")
  cmd+=('--user' "${MYTHIC_BEASTS_API_KEY}:${MYTHIC_BEASTS_SECRET}")
  cmd+=('--user-agent' "delphyne/${VERSION} curl/${CURL_VERSION}")
  if [ -n "${response_format}" ]; then
    cmd+=('--header' "Accept: ${response_format}")
  fi
  cmd+=('--write-out' "%{http_code}" '--output' "${tempbody}" '--dump-header' "${tempheaders}")

  # Add request body, if one is given
  if [ -n "${body}" ]; then
    if [ -n "${request_format}" ]; then
      cmd+=('--header' "Content-Type: ${request_format}")
    fi
    cmd+=('--data-binary' "${body}")
  fi

  # Now execute the command we have built up
  set +e
  cmd+=("${url}")
  statuscode="$("${cmd[@]}")"
  curlret="${?}"
  set -e

  if [[ ! "${curlret}" = "0" ]]; then
    _exiterr "Problem connecting to server (${method} for ${url}; curl returned with ${curlret})"
  fi

  # FIXME: check that response is in the expected format

  if [[ ! "${statuscode:0:1}" = "2" ]]; then
    display_error "${tempheaders}" "${tempbody}"
    rm -f "${tempbody}"
    rm -f "${tempheaders}"
    exit 1
  fi

  if { true >&4; } 2>/dev/null; then
    cat "${tempheaders}" >&4
  fi
  cat "${tempbody}"
  rm -f "${tempbody}"
  rm -f "${tempheaders}"
}

display_zones() {
  clean_json | get_json_array_value zones | get_json_array_as_lines | delete_empty_lines
}

# Usage: delphyne zones
# Description: List the registered zones
command_zones() {
  echo "Getting zones" >&2
  response_format='application/json'
  http_request get "/zones" | display_zones
}

# Usage: delphyne get <zone>
# Description: Get a DNS zone
command_get() {
  echo "Getting zone ${1}" >&2
  response_format='text/dns'
  http_request get "/zones/${1}/records"
}

# Usage: delphyne dynamic <hostname>
# Description: Update hostname to public IP address of this machine
command_dynamic() {
  response_format='application/json'
  ip_version="${ip_version:--4}"

  echo "Dynamic update for ${1}" >&2
  message="$(http_request post "/dynamic/${1}" | clean_json | get_json_string_value message)"
  if [ -n "${message}" ]; then
    echo " => ${message}"
  fi
}

# Usage: delphyne help
# Description: Show help text
command_help() {
  printf "Usage: %s <command>\n\n" "${0}"
  echo "Commands:"
  grep -e '^[[:space:]]*# Usage:' -e '^[[:space:]]*# Description:' -e '^command_.*()[[:space:]]*{' "${0}" | while read -r usage; read -r description; read -r command; do
    if [[ ! "${usage}" =~ Usage ]] || [[ ! "${description}" =~ Description ]] || [[ ! "${command}" =~ ^command_ ]]; then
      _exiterr "Error generating help text."
    fi
    printf " %-32s %s\n" "${usage##"# Usage: "}" "${description##"# Description: "}"
  done
}

# Usage: delphyne version
# Description: Print version information
command_version() {
  echo "Delphyne version: ${VERSION}"
  echo ""
  echo "Used software:"
  [[ -n "${BASH_VERSION:-}" ]] && echo " bash: ${BASH_VERSION}"
  echo " curl: $(curl --version 2>&1 | head -n1 | cut -d" " -f1-2)"
  exit 0
}

set_defaults() {
  CURL="${CURL:-curl}"
  MYTHIC_BEASTS_API_KEY="${MYTHIC_BEASTS_API_KEY:-}"
  MYTHIC_BEASTS_SECRET="${MYTHIC_BEASTS_SECRET:-}"

  ip_version="${ip_version:-}"
  request_format=
  response_format=
}

# Determine OS type
OSTYPE="$(uname)"

main() {
  # Check for missing dependencies
  check_dependencies
  
  set_defaults

  case "${1}" in
    dynamic) command_dynamic "${2}";;
    get) command_get "${2}";;
    version) command_version;;
    zones) command_zones;;
    *) command_help; exit 1;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
  main "${@:-}"
fi
